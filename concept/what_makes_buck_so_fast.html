<!doctype html><html><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns#"><title>Buck: What Makes Buck so Fast?</title><link type="image/png" rel="icon" href="/buck/static/favicon.png" /><meta http-equiv="content-type" content="text/html;charset=utf-8"><link type="text/css" rel="stylesheet" href="/buck/static/buck.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-40185670-1', 'github.io'); ga('send', 'pageview');</script><meta property="og:locale" content="en_US"><meta property="og:title" content="What Makes Buck so Fast?"><meta property="og:site_name" content="Buck: an Android build tool"><meta property="og:image" content="http://newsroom.fb.com/display-media/265/4"><meta property="og:image:type" content="image/png"><meta property="og:image:width" content="690"><meta property="og:image:height" content="690"><meta property="og:type" content="article"><meta property="fb:admins" content="584556688222168"></head><body><a href="https://github.com/facebook/buck"><img id="fork" src="/buck/static/fork_me.png" alt="Fork me on GitHub"></a><div id="fb-root"></div><script>(function(d, s, id) {var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=584556688222168"; fjs.parentNode.insertBefore(js, fjs);}(document, 'script', 'facebook-jssdk'));</script><h1><div class="titlebar"><div class="fb-like buck_like" data-send="false" data-layout="standard" data-width="350" data-show-faces="false" data-colorscheme="light" data-action="like"></div><div>Buck: What Makes Buck so Fast?</div></div></h1><div class="content_frame"><div class="toc"><ul class="toc_root"><li><span class="toc_header">Getting Started</span><ul><li><a href="/buck/">Overview</a><li><a href="/buck/setup/quick_start.html">Quick Start</a><li><a href="/buck/setup/install.html">Downloading and Installing Buck</a></ul><li><span class="toc_header">About</span><ul><li><a href="/buck/concept/what_makes_buck_so_fast.html">What Makes Buck so Fast?</a><li><a href="/buck/concept/troubleshooting.html">Troubleshooting</a><li><a href="/buck/about/performance_tuning.html">Performance Tuning</a><li><a href="/buck/concept/faq.html">FAQ</a></ul><li><span class="toc_header">Concepts</span><ul><li><a href="/buck/concept/build_rule.html">Build Rule</a><li><a href="/buck/concept/build_target.html">Build Target</a><li><a href="/buck/concept/build_file.html">Build File</a><li><a href="/buck/concept/buckversion.html">.buckversion</a><li><a href="/buck/concept/nobuckcheck.html">.nobuckcheck</a><li><a href="/buck/concept/buckconfig.html">.buckconfig</a><li><a href="/buck/concept/build_target_pattern.html">Build Target Pattern</a><li><a href="/buck/concept/visibility.html">Visibility</a></ul><li><span class="toc_header">Build Rules</span><ul><li><a href="/buck/rule/android_binary.html">android_binary()</a><li><a href="/buck/rule/android_library.html">android_library()</a><li><a href="/buck/rule/android_resource.html">android_resource()</a><li><a href="/buck/rule/apk_genrule.html">apk_genrule()</a><li><a href="/buck/rule/gen_aidl.html">gen_aidl()</a><li><a href="/buck/rule/genrule.html">genrule()</a><li><a href="/buck/rule/java_binary.html">java_binary()</a><li><a href="/buck/rule/java_library.html">java_library()</a><li><a href="/buck/rule/java_test.html">java_test()</a><li><a href="/buck/rule/keystore.html">keystore()</a><li><a href="/buck/rule/ndk_library.html">ndk_library()</a><li><a href="/buck/rule/prebuilt_jar.html">prebuilt_jar()</a><li><a href="/buck/rule/prebuilt_native_library.html">prebuilt_native_library()</a><li><a href="/buck/rule/project_config.html">project_config()</a></ul><li><span class="toc_header">Functions</span><ul><li><a href="/buck/function/genfile.html">genfile()</a><li><a href="/buck/function/glob.html">glob()</a><li><a href="/buck/function/include_defs.html">include_defs()</a></ul><li><span class="toc_header">Commands</span><ul><li><a href="/buck/command/audit.html">buck audit</a><li><a href="/buck/command/build.html">buck build</a><li><a href="/buck/command/clean.html">buck clean</a><li><a href="/buck/command/install.html">buck install</a><li><a href="/buck/command/project.html">buck project</a><li><a href="/buck/command/quickstart.html">buck quickstart</a><li><a href="/buck/command/targets.html">buck targets</a><li><a href="/buck/command/test.html">buck test</a><li><a href="/buck/command/uninstall.html">buck uninstall</a><li><a href="/buck/command/buckd.html">buckd</a></ul><li><span class="toc_header">Extending Buck</span><ul><li><a href="/buck/extending/macros.html">Custom Macros</a><li><a href="/buck/extending/rules.html">Custom Rules</a></ul><li><span class="toc_header">Contributing to Buck</span><ul><li><a href="https://groups.google.com/group/buck-build">Discussion Group</a><li><a href="https://github.com/facebook/buck/issues/new">Report a Bug</a><li><a href="/buck/contributing/development.html">Development Workflow</a><li><a href="/buck/contributing/codestyle.html">Code Style</a><li><a href="/buck/javadoc">API</a><li><a href="https://github.com/facebook/buck">Browse the Source Code</a></ul></ul></div><div class="content"><div class="overview">Buck exploits a number of strategies to reduce build times.<h2>A build rule knows all of the inputs that can affect its output</h2>Buck is designed so that anything that can affect the output of a build rule must be specified as an input to the build rule: hidden state is not allowed. (This is also important for ensuring that results are consistent and reproducible for all developers.) Therefore, we can be sure that once a rule's <code>deps</code> are satisfied, the rule itself can be built. This gives us confidence that the <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> that results from build rules and their <code>deps</code> is true: all dependencies are captured in the graph.<p>Having a DAG makes it straightforward for rules to be built in parallel, which can dramatically reduce build times. The execution model for Buck is very simple: starting with the leaf nodes of the graph, add them to a queue of rules to be built. When a thread is available, a rule is removed from the queue, and built. Assuming it is built successfully, it notifies all of the rules that depend on it that it is done. When a rule gets such a notification, it checks whether all its dependencies have been satisfied, and if so, it gets added to the queue. Computation proceeds in this manner until all of the nodes in the graph have gone through the queue. Therefore, breaking modules into finer dependencies creates opportunities for increased parallelism, improving throughput.<h2>Buck can store the outputs it generates in a cache</h2>A build rule knows all of the inputs that can affect its output, and therefore it can combine that information into a hash that represents the total input. This hash is used as a <em>cache key</em> where the associated value in the cache is the output produced by the rule. (See <a href="/buck/concept/buckconfig.html"><code>.buckconfig</code></a> for information on how to set up a cache.) The following information contributes to the cache key for a build rule:<ul><li>The values of the arguments used to define the build rule in the build file.<li>The contents of any file arguments for the build rule.<li>The version of Buck being used to build the rule. (This means that upgrading Buck to a new version invalidates all of the cache keys generated by the old version.)<li>The cache key for each of the rule's <code>deps</code>.</ul><p>When Buck begins to build a build rule, the first thing it does is compute the <em>cache key</em> for the rule. If there is a hit in any of the caches specified in <code>.buckconfig</code>, then it will fetch the rule's output from the cache instead of building the rule locally. For outputs that are expensive to compute, this is a substantial savings. It also makes it fast to rebuild when switching between branches in a <a href="http://en.wikipedia.org/wiki/Distributed_version_control_system">DVCS</a> such as Git or Mercurial.<p>Because Buck uses the cache key to determine whether to rebuild a rule, you should never have to run <a href="/buck/command/clean.html"><code>buck clean</code></a>. If anything that could affect the output of the rule changes, then the cache key should change, as well. Because the change in input will cause a cache miss, Buck will rebuild the rule, overwriting its old outputs. Since out-of-date outputs are guaranteed to be overwritten, there is no reason to clean the build.<p>If you are using some sort of <a href="http://en.wikipedia.org/wiki/Continuous_integration">continuous integration (CI)</a> system, you will likely want your CI builds to populate a cache that can be read by your local builds. That way, when a developer syncs to a revision that has already been built on your CI system, running <code>buck build</code> should not build anything locally, as all outputs should be able to be pulled from the cache. This works because the cache key computed by Buck when run on the CI system should match the key computed by Buck on your local machine.<h2>A Java rule computes its ABI when it is built</h2>Oftentimes, a developer will modify Java code in a way that does not affect its interface. For example, adding or removing private methods, as well as modifying the implementation of existing methods (regardless of their visibility), does not change the <a href="http://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> of a Java file.<p>When Buck builds a <a href="/buck/rule/java_library.html"><code>java_library</code></a> rule, it also computes its ABI<sup><a href="#footnote-abi">1</a></sup>. Normally, modifying a private method in a <a href="/buck/rule/java_library.html"><code>java_library</code></a> would cause it and all rules that depend on it to be rebuilt because the change in cache keys would propagate up the DAG. However, Buck has special logic for a <a href="/buck/rule/java_library.html"><code>java_library</code></a> where, if the <code>.java</code> input files have not changed since the previous build, and the ABI for each of its Java dependencies has not changed since the previous build, then the <a href="/buck/rule/java_library.html"><code>java_library</code></a> will not be recompiled. This is valid because we know that neither the input <code>.java</code> files nor the ABI against which they would be compiled has changed, so the result would be the same if the rule were rebuilt. This localizes how much Java code needs to be recompiled in response to a change, again reducing build times.<hr><p><sup id="footnote-abi">1</sup>The ABI computed by Buck is stricter than <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html">what the Java Language Specification (JLS) uses to define binary compatibility</a>. In Buck, the ABI defines an equivalence relationship, whereas in the JLS, it does not. This is primarily done because the ABI is represented as a SHA-1 hash, which is cheap to compare. However, this does mean that adding a new method to a class results in a new ABI for a <a href="/buck/rule/java_library.html"><code>java_library</code></a> in Buck, which triggers a rebuild in dependent rules. By comparison, the JLS would consider the old and new versions of the library binary compatible, thereby determining recompilation of dependent rules unnecessary.</div></div></div></body></html>